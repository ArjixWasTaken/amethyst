import { dir_create, dir_exists, file_glob, file_write, file_exists, file_read } from "std/fs"
import { input_confirm, env_var_get } from "std/env"
import { starts_with, ends_with, split, split_lines, join, trim, replace } from "std/text"
import { array_pop } from "std/array"

import { parent_dir, basename } from "./path.ab"
import { info, warn, fatal } from "./utils.ab"
import { is_available_locally, is_available_remotely, download } from "./amber_manager.ab"

pub fun locate_project(): [Text] {
    let cwd = trust $ pwd $

    loop {
        if not dir_exists(cwd) {
            return ["no", ""]
        }

        if file_exists("{cwd}/amethyst.ini") {
            return ["yes", cwd]
        }

        if cwd == "/" {
            break
        }

        const new_cwd = parent_dir(cwd)
        cwd = new_cwd
    }

    return ["no", ""]
}

pub fun open_ini(ini_file: Text) {
    const tmp_dir = trust env_var_get("AM_INI_DIR")

    const lines = trust file_read(ini_file)
    let current_section = ""

    for line in split_lines(lines) {
        const line = trim(line)
        if starts_with(line, "#") or line == "" {
            continue
        }

        const is_section = starts_with(line, "[") and ends_with(line, "]")
        if is_section {
            current_section = line
            for i in ["[", "]"] {
                current_section = replace(current_section, i, "")
            }

            trust dir_create("{tmp_dir}/{current_section}")
            continue
        }

        const segments = split(line, "=")
        if len(segments) != 2 {
            continue
        }

        const key = trim(segments[0])
        const value = trim(segments[1])

        trust file_write("{tmp_dir}/{current_section}/{key}", value)
    }
}

pub fun close_ini(ini_file: Text) {
    const tmp_dir = trust env_var_get("AM_INI_DIR")
    let buffer = ""

    const sections = trust file_glob("{tmp_dir}/*")
    for section in sections {
        const section = basename(section)
        buffer += "[{section}]\n"

        const keys = trust file_glob("{tmp_dir}/{section}/*")
        for entry in keys {
            const key = basename(entry)
            const value = trust file_read(entry)
            buffer += "{key} = {value}\n"
        }

        buffer += "\n"
    }

    trust file_write(ini_file, trim(buffer))
}

pub fun list_ini_sections(): [Text] {
    const tmp_dir = trust env_var_get("AM_INI_DIR")
    const sections = trust file_glob("{tmp_dir}/*")

    let section_names = [Text]
    for section in sections {
        section_names += [basename(section)]
    }

    return section_names
}

pub fun list_ini_section_properties(section: Text): [Text] {
    const tmp_dir = trust env_var_get("AM_INI_DIR")
    const keys = trust file_glob("{tmp_dir}/{section}/*")

    let key_names = [Text]
    for key in keys {
        key_names += [basename(key)]
    }

    return key_names
}

pub fun list_ini_section_values(section: Text): [Text] {
    const tmp_dir = trust env_var_get("AM_INI_DIR")
    const keys = trust file_glob("{tmp_dir}/{section}/*")

    let values = [Text]
    for key in keys {
        values += [trust file_read(key)]
    }

    return values
}

pub fun get_ini_value(section: Text, property: Text): Text {
    const tmp_dir = trust env_var_get("AM_INI_DIR")

    const path = "{tmp_dir}/{section}/{property}"
    if not file_exists(path) {
        return ""
    }

    return trust file_read(path)
}

pub fun set_ini_value(section: Text, property: Text, value: Text) {
    const tmp_dir = trust env_var_get("AM_INI_DIR")

    const path = "{tmp_dir}/{section}/{property}"
    trust file_write(path, value)
}

pub fun get_project_properties(project: Text, section: Text): [Text] {
    const project_file = "{project}/amethyst.ini"
    if not file_exists(project_file) {
        return [Text]
    }

    let properties = [Text]

    const lines = trust file_read(project_file)
    let current_section = ""

    for line in split_lines(lines) {
        const line = trim(line)

        if starts_with(line, "#") or line == "" {
            continue
        }
        
        const is_section = starts_with(line, "[") and ends_with(line, "]")
        if is_section {
            current_section = line
            for i in ["[", "]"] {
                current_section = replace(current_section, i, "")
            }
            continue
        }

        const segments = split(line, "=")
        if len(segments) != 2 {
            continue
        }

        const key = trim(segments[0])
        const value = trim(segments[1])

        if current_section == section {
            properties += [key]
        }
    }

    return properties
}

pub fun get_project_property(project: Text, section: Text, property: Text): Text {
    const project_file = "{project}/amethyst.ini"
    if not file_exists(project_file) {
        return ""
    }

    const lines = trust file_read(project_file)
    let current_section = ""

    for line in split_lines(lines) {
        const line = trim(line)

        if starts_with(line, "#") or line == "" {
            continue
        }
        
        const is_section = starts_with(line, "[") and ends_with(line, "]")
        if is_section {
            current_section = line
            for i in ["[", "]"] {
                current_section = replace(current_section, i, "")
            }
            continue
        }

        const segments = split(line, "=")
        if len(segments) != 2 {
            continue
        }

        const key = trim(segments[0])
        const value = trim(segments[1])

        if current_section == section and key == property {
            return value
        }
    }

    return ""
}

pub fun get_project_amber() {
    const project = locate_project()
    const version = get_project_property(project[1], "amethyst", "amber-version")

    if version == "system" {
        // TODO: Add support for using system's amber
    }

    if not is_available_locally(version) {
        warn("Amber {version} is not available locally.")
        info("Checking if it is available for download...")

        if not is_available_remotely(version) {
            fatal("Couldn't satisfy version requirement for amber {version}")
        }

        info("Amber {version} is available for download.")
        if not input_confirm("Proceed with download?") {
            exit(1)
        }

        info("Downloading amber {version}...")
        download(version)
    }

    return version
}
